"use strict";(self.webpackChunkkinderheim=self.webpackChunkkinderheim||[]).push([[7358],{3905:function(e,t,r){r.d(t,{Zo:function(){return m},kt:function(){return u}});var a=r(67294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function n(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?n(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function o(e,t){if(null==e)return{};var r,a,i=function(e,t){if(null==e)return{};var r,a,i={},n=Object.keys(e);for(a=0;a<n.length;a++)r=n[a],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(a=0;a<n.length;a++)r=n[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var p=a.createContext({}),l=function(e){var t=a.useContext(p),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},m=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var r=e.components,i=e.mdxType,n=e.originalType,p=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=l(r),u=i,g=c["".concat(p,".").concat(u)]||c[u]||h[u]||n;return r?a.createElement(g,s(s({ref:t},m),{},{components:r})):a.createElement(g,s({ref:t},m))}));function u(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var n=r.length,s=new Array(n);s[0]=c;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var l=2;l<n;l++)s[l]=r[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,r)}c.displayName="MDXCreateElement"},46478:function(e,t,r){r.r(t),r.d(t,{assets:function(){return m},contentTitle:function(){return p},default:function(){return u},frontMatter:function(){return o},metadata:function(){return l},toc:function(){return h}});var a=r(87462),i=r(63366),n=(r(67294),r(3905)),s=["components"],o={},p="Parsing",l={unversionedId:"computer-science/parsing",id:"computer-science/parsing",title:"Parsing",description:"Tree-sitter is neat.",source:"@site/docs/computer-science/parsing.md",sourceDirName:"computer-science",slug:"/computer-science/parsing",permalink:"/kinderheim/computer-science/parsing",draft:!1,editUrl:"https://github.com/ecioran/kinderheim/docs/computer-science/parsing.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"TLA+",permalink:"/kinderheim/computer-science/formal-verification/tla"},next:{title:"Consciousness",permalink:"/kinderheim/consciousness/"}},m={},h=[{value:"Links",id:"links",level:2}],c={toc:h};function u(e){var t=e.components,r=(0,i.Z)(e,s);return(0,n.kt)("wrapper",(0,a.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"parsing"},"Parsing"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://tree-sitter.github.io/tree-sitter/"},"Tree-sitter")," is neat."),(0,n.kt)("h2",{id:"links"},"Links"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://medium.com/unifiedjs/collectively-evolving-through-crowdsourcing-22c359ea95cc"},"Crowdsourcing the evolution of text parsing with unified (2018)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/inhabitedtype/angstrom"},"Angstrom")," - Parser combinators built for speed and memory efficiency."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/tree-sitter/tree-sitter"},"tree-sitter")," - Parser generator tool and an incremental parsing library. (",(0,n.kt)("a",{parentName:"li",href:"https://tree-sitter.github.io/tree-sitter/"},"Web"),") (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=26225298"},"HN"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/thautwarm/RBNF.jl"},"RBNF.jl")," - DSL for modern parsing."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/"},"Parse, don\u2019t validate (2019)")," (",(0,n.kt)("a",{parentName:"li",href:"https://lobste.rs/s/uemphs/parse_don_t_validate"},"Lobsters"),") (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=21476261"},"HN"),") (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=27639890"},"HN"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/yeslogic/ddl"},"DDL")," - Declarative data definition language for formally specifying binary data formats."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://lihautan.com/json-parser-with-javascript/"},"JSON Parser with JavaScript")," (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=21772336"},"HN"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://itnext.io/parsing-18-billion-lines-json-with-go-738be6ee5ed2"},"Parsing 18 billion JSON lines with Go (2019)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=wlvKAT7SZIQ"},"Parsing JSON Really Quickly: Lessons Learned (2019)")," (",(0,n.kt)("a",{parentName:"li",href:"https://blog.metaobject.com/2020/04/somewhat-less-lethargic-json-support.html"},"Article"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=dDtZLm7HIJs"},"Functional Parsing - Computerphile (2020)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/google/cel-spec"},"Common Expression Language")," - Implements common semantics for expression evaluation, enabling different applications to more easily interoperate. (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=25377620"},"HN"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/unifiedjs/awesome-unified"},"Awesome Unified")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"http://dmitrysoshnikov.com/courses/essentials-of-interpretation/"},"Essentials of Interpretation (2020)")," (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=22549265"},"HN"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/pest-parser/pest"},"pest")," - General purpose parser written in Rust with a focus on accessibility, correctness, and performance. (",(0,n.kt)("a",{parentName:"li",href:"https://pest.rs/"},"Web"),") (",(0,n.kt)("a",{parentName:"li",href:"https://lobste.rs/s/nplikm/pest_parser_rust_using_pegs"},"Lobsters"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html"},"Simple but Powerful Pratt Parsing (2020)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://arxiv.org/pdf/1910.09521.pdf"},"Reasoning About Recursive Tree Traversals (2019)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/syntax-tree/unist"},"unist")," - Specification for syntax trees."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.youtube.com/playlist?list=PLGNbPb3dQJ_6aPNnlBvXGyNMlDtNTqN5I"},"Essentials of Parsing (2020)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/jackmott/rust-lexer"},"Port of Rob Pike's Go lexer to Rust")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/kach/nearley"},"nearley")," - Streaming parser with support for catching errors gracefully and providing all parsings for ambiguous grammars."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/scinfu/SwiftSoup"},"SwiftSoup")," - Pure Swift HTML Parser, with best of DOM, CSS, and jquery (Supports Linux, iOS, Mac, tvOS, watchOS)."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/goccmack/gogll"},"GoGLL")," - Generates a GLL parser and FSA-based lexer for any context-free grammar. The generated code is Go or Rust."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.aaronraff.dev/blog/how-to-write-a-lexer-in-go"},"How to Write a Lexer in Go (2020)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/zeek/spicy"},"Spicy")," - C++ parser generator that makes it easy to create robust parsers for network protocols, file formats, and more."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://soft-dev.org/pubs/html/diekmann_tratt__dont_panic/"},"Don't Panic! Better, Fewer, Syntax Errors for LR Parsers (2020)")," (",(0,n.kt)("a",{parentName:"li",href:"https://lobste.rs/s/pje7ff/don_t_panic_better_fewer_syntax_errors_for"},"Lobsters"),") (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=23850718"},"HN"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2014/09/chron.html"},"Parsing: a timeline (2014)")," (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=8290681"},"HN"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://tratt.net/laurie/blog/entries/which_parsing_approach.html"},"Which Parsing Approach? (2020)")," (",(0,n.kt)("a",{parentName:"li",href:"https://lobste.rs/s/9pcqys/which_parsing_approach"},"Lobsters"),") (",(0,n.kt)("a",{parentName:"li",href:"https://www.reddit.com/r/Compilers/comments/it80pu/which_parsing_approach/"},"Reddit"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/lark-parser/lark/"},"Lark")," - Parsing toolkit for Python, built with a focus on ergonomics, performance and modularity."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://rust-analyzer.github.io//blog/2020/09/16/challeging-LR-parsing.html"},"Challenging LR Parsing (2020)")," (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=24492675"},"HN"),") (",(0,n.kt)("a",{parentName:"li",href:"https://lobste.rs/s/t9oewt/challenging_lr_parsing"},"Lobsters"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://utcc.utoronto.ca/~cks/space/blog/programming/WhyRDParsersForMe"},"Why I write recursive descent parsers (despite their issues) (2020)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/orangeduck/mpc"},"mpc")," - Lightweight and powerful Parser Combinator library for C."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://rdambrosio016.github.io/rust/2020/09/18/pure-ast-based-linting-sucks.html"},"Pure AST based linting sucks (2020)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/dloss/binary-parsing"},"Awesome binary parsing")," - List of generic tools for parsing binary data structures, such as file formats, network protocols or bitstreams."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.bjmc.lu.lv/fileadmin/user_upload/lu_portal/projekti/bjmc/Contents/7_2_01_Saikunas.pdf"},"Parsing with Scannerless Earley Virtual Machines (2019)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/tuxmark5/north"},"North")," - Experimental SEVM (Scannerless Earley Virtual Machine) parser implementation."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://tiarkrompf.github.io/notes/?/just-write-the-parser/"},"Just write the parser")," - Whirlwind tour of writing parsers by hand. (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=24837898"},"HN"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"http://dmitrysoshnikov.com/courses/parsing-algorithms/"},"Parsing Algorithms course")," (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=24898210"},"HN"),") (",(0,n.kt)("a",{parentName:"li",href:"https://github.com/DmitrySoshnikov/letter-source"},"Code"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/JakeWheat/intro_to_parsing"},"Intro to Parsing with Parsec in Haskell")," - Demonstrates the basics of Parsec and goes on to build a SQL query parser."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://kitten.sh/parser-generator-dsl"},"Parser Generator DSLs (2020)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://astexplorer.net/"},"AST Explorer")," - Web tool to explore the ASTs generated by various parsers. (",(0,n.kt)("a",{parentName:"li",href:"https://github.com/fkling/astexplorer"},"Code"),") (",(0,n.kt)("a",{parentName:"li",href:"https://github.com/JamieMason/astexplorer.app"},"Web App Code"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://lezer.codemirror.net/"},"Lezer")," - Incremental GLR parser intended for use in an editor or similar system, which needs to keep a representation of the program current during changes and in the face of syntax errors. (",(0,n.kt)("a",{parentName:"li",href:"https://github.com/lezer-parser"},"GitHub"),") (",(0,n.kt)("a",{parentName:"li",href:"https://github.com/lezer-parser/lezer"},"Code"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/TOPLLab/GraphRedex"},"GraphRedex")," - Open-source tool that empowers language designers to interactively explore their reduction graphs."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/jneen/parsimmon"},"Parsimmon")," - Small library for writing big parsers made up of lots of little parsers."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://bernsteinbear.com/blog/inline-caching-quickening/"},"Inline caching: quickening (2021)")," (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=26054573"},"HN"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://rahul.gopinath.org/post/2021/02/06/earley-parsing/"},"Earley Parser (2021)")," (",(0,n.kt)("a",{parentName:"li",href:"https://lobste.rs/s/gadd2l/earley_parser"},"Lobsters"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/syntax-tree/awesome-syntax-tree"},"awesome syntax-tree")," - Curated list of awesome syntax-tree, unist, hast, xast, mdast, nlcst resources."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://lobste.rs/s/l6yieh/top_down_parsing_with_parsing_contexts"},"Top-Down Parsing with Parsing Contexts -- A simple approach to context sensitive parsing (2014)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://jobjo.github.io/2019/05/19/applicative-parsing.html"},"Applicative parsing (2019)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=6oQLRhw5Ah0&list=PLP29wDx6QmW5yfO1LAgO8kU3aQEj8SIrU"},"Parser Combinators From Scratch (2020)")," (",(0,n.kt)("a",{parentName:"li",href:"https://github.com/LowLevelJavaScript/Parser-Combinators-From-Scratch"},"Code"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://ohmlang.github.io/"},"Ohm")," - Parser generator consisting of a library and a domain-specific language. (",(0,n.kt)("a",{parentName:"li",href:"https://github.com/harc/ohm"},"Code"),") (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=26603393"},"HN"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://arxiv.org/pdf/2005.06444.pdf"},"Pika parsing: reformulating packrat parsing as a dynamic programming algorithm solves the left recursion and error recovery problems (2020)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/Unibeautify/sparser"},"Sparser")," - Framework of various language parsers. (",(0,n.kt)("a",{parentName:"li",href:"https://sparser.io/"},"Web"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://drewdevault.com/2021/04/22/Our-self-hosted-parser-design.html"},"Parsers all the way down: writing a self-hosting parser (2021)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/jcoglan/canopy"},"Canopy")," - Parser compiler for Java, JavaScript, Python, Ruby. (",(0,n.kt)("a",{parentName:"li",href:"http://canopy.jcoglan.com/"},"Docs"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://norswap.com/pubs/thesis.pdf"},"Principled Procedural Parsing (2019)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/parsix/parsix"},"Parsix")," - Parse, don't validate. (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=27166162"},"HN"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/osa1/parsegen"},"parsegen")," - LR parser generator, similar to happy, ocamlyacc, and lalrpop."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/inspirer/textmapper"},"TextMapper")," - Lexer and Parser generator. (",(0,n.kt)("a",{parentName:"li",href:"https://textmapper.org/"},"Web"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/waxeye-org/waxeye"},"Waxeye Parser Generator")," - Parser generator based on parsing expression grammars (PEGs)."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/kevinmehall/rust-peg"},"rust-peg")," - Parsing Expression Grammar (PEG) parser generator for Rust."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://iximiuz.com/en/posts/rust-writing-parsers-with-nom/"},"Rust - Writing Parsers With nom Parser Combinator Framework (2021)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://dundalek.com/grammkit/"},"GrammKit")," - Tool for generating syntax diagrams (also known as railroad diagrams) for parser grammars. (",(0,n.kt)("a",{parentName:"li",href:"https://github.com/dundalek/GrammKit"},"Code"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/pyparsing/pyparsing"},"PyParsing")," - Python library for creating PEG parsers."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://wiki.alopex.li/OnParsers"},"On Parsers")," (",(0,n.kt)("a",{parentName:"li",href:"https://lobste.rs/s/7it43u/on_parsers"},"Lobsters"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.brandons.me/blog/casual-parsing-javascript"},"Casual Parsing in JavaScript (2021)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://notes.eatonphil.com/parser-generators-vs-handwritten-parsers-survey-2021.html"},"Parser generators vs. handwritten parsers: surveying major language implementations in 2021")," (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=28258945"},"HN"),") (",(0,n.kt)("a",{parentName:"li",href:"https://lobste.rs/s/10pkib/parser_generators_vs_handwritten"},"Lobsters"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://kaitai.io/"},"Kaitai Struct")," - Declarative binary format parsing language. (",(0,n.kt)("a",{parentName:"li",href:"https://lobste.rs/s/pnfkzp/kaitai_struct_declarative_binary_format"},"Lobsters"),") (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=30715406"},"HN"),") (",(0,n.kt)("a",{parentName:"li",href:"https://ide.kaitai.io/"},"IDE"),") (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=30894111"},"HN"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/MasterQ32/parser-toolkit"},"Parser toolkit")," - Toolkit that makes it easier to write recursive-descent parsers in Zig."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/neogeny/TatSu"},"TatSu")," - Generates Python parsers from grammars in a variation of EBNF. (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=31293716"},"HN"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/Jezza/progger"},"Progger")," - Simple set of parser and lexer tools. Built on top of logos and bumpalo."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://sgt.hootr.club/molten-matter/types-of-parser-combinators/"},"Types of Parser Combinators (2021)")," (",(0,n.kt)("a",{parentName:"li",href:"https://lobste.rs/s/5agmsv/types_parser_combinators"},"Lobsters"),") (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=29246227"},"HN"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://blog.drewolson.org/parsing-permutations"},"Parsing Permutations (2021)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.masteringemacs.org/article/tree-sitter-complications-of-parsing-languages"},"Tree Sitter and the Complications of Parsing Languages")," (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=29327424"},"HN"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://adambcomer.com/lin-tree-solver/"},"Linguistics Tree Solver")," - Tool automatically builds linguistics syntax trees. (",(0,n.kt)("a",{parentName:"li",href:"https://github.com/adambcomer/lin-tree-solver"},"Code"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://begriffs.com/posts/2021-11-28-practical-parsing.html"},"Practical parsing with Flex and Bison (2021)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://dcreager.net/tree-sitter/map/"},"A map of the tree-sitter ecosystem (2021)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://dcreager.net/tree-sitter/getting-started/"},"Getting started with tree-sitter (2021)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/alecthomas/participle"},"Participle")," - Dead simple parser package for Go."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://aclanthology.org/2021.emnlp-main.393/"},"Genre as Weak Supervision for Cross-lingual Dependency Parsing (2021)")," (",(0,n.kt)("a",{parentName:"li",href:"https://github.com/personads/ud-selection"},"Code"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/dmaevsky/rd-parse"},"rd-parse")," - Generic minimalist zero dependencies recursive-descent parser generator in JavaScript."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://peppe.rs/posts/lightweight_linting/"},"Lightweight Linting with Tree-sitter (2022)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/keyvchan/tsls"},"tsls")," - Tree-sitter based language server for general languages."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/obscurecolin/lr"},"Interactive tool for experimenting with LR(1) grammars")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/DmitrySoshnikov/syntax"},"syntax")," - Syntactic analysis toolkit, language-agnostic parser generator."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/rajasegar/ast-builder"},"ast-builder")," - Build your Abstract Syntax Trees (AST) directly by writing code."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://bford.info/packrat/"},"Packrat Parsing and Parsing Expression Grammars")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.pointfree.co/episodes/ep178-invertible-parsing-the-problem"},"Invertible Parsing: The Problem (2022)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://tree-sitter.github.io/tree-sitter/code-navigation-systems"},"Tree-sitter \uff5c Code Navigation Systems")," (",(0,n.kt)("a",{parentName:"li",href:"https://twitter.com/importantshock/status/1496857243043704833"},"Tweet"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://blog.adamchalmers.com/nom-bits/"},"Parsing Bitstreams with Rust and Nom (2022)")," (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=30528609"},"HN"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://blog.adamchalmers.com/nom-chars/"},"Parsing Text with Nom (2022)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://siraben.dev/2022/03/01/tree-sitter.html"},"How to write a tree-sitter grammar in an afternoon (2022)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/stsewd/tree-sitter-comment"},"tree-sitter-comment")," - Tree-sitter grammar for comment tags like TODO, FIXME(user)."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/kamadorueda/santiago"},"Santiago")," - Lexing and parsing toolkit for Rust."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.engr.mun.ca/~theo/Misc/exp_parsing.htm"},"Parsing Expressions by Recursive Descent (1999)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.engr.mun.ca/~theo/Misc/pratt_parsing.htm"},"From Precedence Climbing to Pratt Parsing (2016)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://twitter.com/typeswitch/status/1507756887537815558"},"Favorite approach to lexical analysis (i.e. turning a stream of bytes/characters into a stream of tokens)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://siraben.dev/2022/03/22/tree-sitter-linter.html"},"How to write a linter using tree-sitter in an hour (2022)")," (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=30822544"},"HN"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/nojb/ppx_match_seq"},"ppx_match_seq")," - Syntax for Seq.t parsers."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.pointfree.co/episodes/ep185-tour-of-parser-printers-introduction"},"Tour of Parser-Printers: Introduction (2022)")," (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=30990463"},"HN"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/tree-sitter/py-tree-sitter"},"py-tree-sitter")," - Python bindings to the Tree-sitter parsing library."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://blog.gopheracademy.com/advent-2014/parsers-lexers/"},"Handwritten Parsers & Lexers in Go (2014)")," (",(0,n.kt)("a",{parentName:"li",href:"https://lobste.rs/s/hhhiiz/handwritten_parsers_lexers_go"},"Lobsters"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/krzyzanowskim/tree-sitter-xcframework"},"Binary build of tree-sitter for apple platforms")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/helix-editor/tspm"},"TSPM")," - Open-source tree-sitter package manager."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/keith-packard/lola"},"Lola")," - LL parser table generator."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.huy.rocks/everyday/05-08-2022-parsing-recursive-descent-parser"},"Parsing / Recursive Descent Parser (2022)")," (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=31311218"},"HN"),") (",(0,n.kt)("a",{parentName:"li",href:"https://lobste.rs/s/rb3zjt/parsing_recursive_descent_parser"},"Lobsters"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing"},"Parsing expressions by precedence climbing (2012)")," (",(0,n.kt)("a",{parentName:"li",href:"https://news.ycombinator.com/item?id=31327328"},"HN"),")"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.abubalay.com/blog/2021/12/31/lr-control-flow"},"From recursive descent to LR parsing (2021)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/we-like-parsers/pegen"},"Pegen")," - Parser generator used in CPython to produce the parser used by the interpreter. It allows to produce PEG parsers from a description of a formal Grammar."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/lezer-parser/generator"},"lezer/generator")," - Parser generator for the lezer incremental parser."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/shi-yan/tree-sitter-viewer"},"tree-sitter-viewer")," - Rust lib to visualize tree-sitter syntax tree.")))}u.isMDXComponent=!0}}]);